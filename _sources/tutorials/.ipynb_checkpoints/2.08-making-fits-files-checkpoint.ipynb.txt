{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# How to output KeplerLightCurve's to fits files\n",
    "\n",
    "Once you have started detrending a lightcurve or altered a lightcurve in some way, you may want to save it as a fits file. This allows you to easily share the file with your collaborators or submit your lightcurves as a [MAST High Level Science Product](https://archive.stsci.edu/hlsp/hlsp_guidelines.html) (HLSP). `lightkurve` has the `to_fits()` method which will easily convert your `KeplerLightCurve` object into a fits file.\n",
    "\n",
    "Below is a quick demostration of how `to_fits()` works.\n",
    "\n",
    "*If you are considering contributing a HLSP you may want to read the [guidelines](https://archive.stsci.edu/hlsp/hlsp_guidelines_timeseries.html) for contributing fits files. These include which fits headers are required/suggested for your HLSP to be accepted.*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from lightkurve import KeplerLightCurveFile, KeplerTargetPixelFile"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First we'll download a random lightcurve from MAST."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "lcf = KeplerLightCurveFile.from_archive(757076, quarter=3, verbose=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we'll make some edits to the lightcurve, below we use the PDCSAP flux from MAST, remove NaN values and clip out any outliers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.axes._subplots.AxesSubplot at 0xa25a15c50>"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lc = lcf.PDCSAP_FLUX.remove_nans().remove_outliers()\n",
    "lc.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can use the `to_fits` method to save the lightcurve to a file called *output.fits*."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "hdu = lc.to_fits(path='output.fits', overwrite=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's take a look at the file and check that it behaved as we expect"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<astropy.io.fits.hdu.image.PrimaryHDU object at 0xa25ac6f28>, <astropy.io.fits.hdu.table.BinTableHDU object at 0xa258d1400>]"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from astropy.io import fits\n",
    "hdu = fits.open('output.fits')\n",
    "hdu"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`hdu` is a set of astropy.io.fits objects, which is what we would expect. Lets take a look at the header of the first extension."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "SIMPLE  =                    T / conforms to FITS standards                     \n",
       "BITPIX  =                    8 / array data type                                \n",
       "NAXIS   =                    0 / number of array dimensions                     \n",
       "EXTEND  =                    T / file contains extensions                       \n",
       "NEXTEND =                    2 / number of standard extensions                  \n",
       "EXTNAME = 'PRIMARY '           / name of extension                              \n",
       "EXTVER  =                    1 / extension version number (not format version)  \n",
       "ORIGIN  = 'Unofficial data product' / institution responsible for file          \n",
       "DATE    = '2018-06-11'         / file creation date.                            \n",
       "CREATOR = 'lightkurve'         / pipeline job and program used t                \n",
       "TELESCOP= 'KEPLER  '           / telescope                                      \n",
       "INSTRUME= 'Kepler Photometer'  / detector type                                  \n",
       "OBJECT  = '757076  '           / string version of target id                    \n",
       "KEPLERID=               757076 / unique Kepler target identifier                \n",
       "CHANNEL =                   56 / CCD channel                                    \n",
       "RADESYS = 'ICRS    '           / reference frame of celestial coordinates       \n",
       "RA_OBJ  =            291.03872 / [deg] right ascension                          \n",
       "DEC_OBJ =             36.59813 / [deg] declination                              \n",
       "EQUINOX =                 2000 / equinox of celestial coordinate system         \n",
       "DATE-OBS= '2009-09-18T17:19:59.170'                                             \n",
       "QUARTER =                    3                                                  \n",
       "MISSION = 'Kepler  '                                                            \n",
       "CHECKSUM= 'fAJNh3INf9INf9IN'   / HDU checksum updated 2018-06-11T15:23:08       \n",
       "DATASUM = '0       '           / data unit checksum updated 2018-06-11T15:23:08 "
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hdu[0].header"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Looks like it has all the correct information about the target. What about the second extension?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "XTENSION= 'BINTABLE'           / binary table extension                         \n",
       "BITPIX  =                    8 / array data type                                \n",
       "NAXIS   =                    2 / number of array dimensions                     \n",
       "NAXIS1  =                   20 / length of dimension 1                          \n",
       "NAXIS2  =                 4140 / length of dimension 2                          \n",
       "PCOUNT  =                    0 / number of group parameters                     \n",
       "GCOUNT  =                    1 / number of groups                               \n",
       "TFIELDS =                    4 / number of table fields                         \n",
       "TTYPE1  = 'TIME    '                                                            \n",
       "TFORM1  = 'D       '                                                            \n",
       "TUNIT1  = 'JD      '                                                            \n",
       "TTYPE2  = 'FLUX    '                                                            \n",
       "TFORM2  = 'E       '                                                            \n",
       "TUNIT2  = 'counts  '                                                            \n",
       "TTYPE3  = 'FLUX_ERR'                                                            \n",
       "TFORM3  = 'E       '                                                            \n",
       "TUNIT3  = 'counts  '                                                            \n",
       "TTYPE4  = 'CADENCENO'                                                           \n",
       "TFORM4  = 'J       '                                                            \n",
       "EXTNAME = 'LIGHTCURVE'                                                          \n",
       "CHECKSUM= 'mXjBmUh9mUhAmUh7'   / HDU checksum updated 2018-06-11T15:23:08       \n",
       "DATASUM = '4124418768'         / data unit checksum updated 2018-06-11T15:23:08 "
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hdu[1].header"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This extension has 4 columns, `TIME`, `FLUX`, `FLUX_ERR` and `CADENCENO`. This is great! What about if we wanted to add new keywords to our fits file? HLSP products require some extra keywords. Let's add some keywords to explain who made the data, and what our HLSP is. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "hdu = lc.to_fits(path='output.fits', overwrite=True,\n",
    "                 hlsplead='Kepler/K2 GO office', hlspname='CLEANK2LC', citation='HEDGES2018')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "SIMPLE  =                    T / conforms to FITS standards                     \n",
       "BITPIX  =                    8 / array data type                                \n",
       "NAXIS   =                    0 / number of array dimensions                     \n",
       "EXTEND  =                    T / file contains extensions                       \n",
       "NEXTEND =                    2 / number of standard extensions                  \n",
       "EXTNAME = 'PRIMARY '           / name of extension                              \n",
       "EXTVER  =                    1 / extension version number (not format version)  \n",
       "ORIGIN  = 'Unofficial data product' / institution responsible for file          \n",
       "DATE    = '2018-06-11'         / file creation date.                            \n",
       "CREATOR = 'lightkurve'         / pipeline job and program used t                \n",
       "TELESCOP= 'KEPLER  '           / telescope                                      \n",
       "INSTRUME= 'Kepler Photometer'  / detector type                                  \n",
       "OBJECT  = '757076  '           / string version of target id                    \n",
       "KEPLERID=               757076 / unique Kepler target identifier                \n",
       "CHANNEL =                   56 / CCD channel                                    \n",
       "RADESYS = 'ICRS    '           / reference frame of celestial coordinates       \n",
       "RA_OBJ  =            291.03872 / [deg] right ascension                          \n",
       "DEC_OBJ =             36.59813 / [deg] declination                              \n",
       "EQUINOX =                 2000 / equinox of celestial coordinate system         \n",
       "DATE-OBS= '2009-09-18T17:19:59.170'                                             \n",
       "QUARTER =                    3                                                  \n",
       "HLSPLEAD= 'Kepler/K2 GO office'                                                 \n",
       "HLSPNAME= 'CLEANK2LC'                                                           \n",
       "CITATION= 'HEDGES2018'                                                          \n",
       "MISSION = 'Kepler  '                                                            \n",
       "CHECKSUM= '9imhHfjf9fjfEfjf'   / HDU checksum updated 2018-06-11T15:23:21       \n",
       "DATASUM = '0       '           / data unit checksum updated 2018-06-11T15:23:21 "
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hdu[0].header"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now our new keywords are included in the primary header! What about if we want to add more data to our fits file? We can simply add this in the same way. Let's add the data quality to our fits file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "hdu = lc.to_fits(path='output.fits', overwrite=True,\n",
    "                 hlsplead='Kepler/K2 GO office', hlspname='CLEANK2LC', citation='HEDGES2018',\n",
    "                 quality=lc.quality)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "XTENSION= 'BINTABLE'           / binary table extension                         \n",
       "BITPIX  =                    8 / array data type                                \n",
       "NAXIS   =                    2 / number of array dimensions                     \n",
       "NAXIS1  =                   28 / length of dimension 1                          \n",
       "NAXIS2  =                 4140 / length of dimension 2                          \n",
       "PCOUNT  =                    0 / number of group parameters                     \n",
       "GCOUNT  =                    1 / number of groups                               \n",
       "TFIELDS =                    5 / number of table fields                         \n",
       "TTYPE1  = 'TIME    '                                                            \n",
       "TFORM1  = 'D       '                                                            \n",
       "TUNIT1  = 'JD      '                                                            \n",
       "TTYPE2  = 'FLUX    '                                                            \n",
       "TFORM2  = 'E       '                                                            \n",
       "TUNIT2  = 'counts  '                                                            \n",
       "TTYPE3  = 'FLUX_ERR'                                                            \n",
       "TFORM3  = 'E       '                                                            \n",
       "TUNIT3  = 'counts  '                                                            \n",
       "TTYPE4  = 'CADENCENO'                                                           \n",
       "TFORM4  = 'J       '                                                            \n",
       "TTYPE5  = 'QUALITY '                                                            \n",
       "TFORM5  = 'K       '                                                            \n",
       "EXTNAME = 'LIGHTCURVE'                                                          \n",
       "CHECKSUM= 'HAfJH9d9HAdGH7d9'   / HDU checksum updated 2018-06-11T15:23:24       \n",
       "DATASUM = '4228051568'         / data unit checksum updated 2018-06-11T15:23:24 "
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hdu[1].header"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now the quality from our lightcurve appears in the second extension. Once all your lightcurves are saved as fits files and you have a README file, you can consider submitting your data produces to MAST."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
